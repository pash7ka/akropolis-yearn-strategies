// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.6.12;
pragma experimental ABIEncoderV2;

import "@yearnvaults/contracts/BaseStrategy.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/SafeERC20.sol";
import "@openzeppelin/contracts/utils/Address.sol";
//import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import "@openzeppelin/contracts/math/SafeMath.sol";
import "../../interfaces/IERC20Detailed.sol";
import "../../interfaces/compound/CErc20.sol";
import "../../interfaces/compound/Comptroller.sol";
import "../../interfaces/compound/PriceFeed.sol";

contract StrategyCompoundErc20 is BaseStrategy {
    using SafeERC20 for IERC20;
    using Address for address;
    using SafeMath for uint256;

    uint256 private constant EXP = 1e18;
    uint256 private constant MAX_UINT256 = uint256(-1);

    CErc20 public cToken;
    Comptroller public comptroller;
    IERC20 public comp;
    PriceFeed public oracle;
    uint256 public reserveFactor;
    uint8 public maxBorrowCycles;
    uint8 internal cTokenDecimals;
    uint8 internal underlyingDecimals;

    /**
     * @param _vault address of Vault
     * @param _cToken address of cToken
     * @param _reserveFactor part of available collateral to left in reserve. This is multiplied to liquidity available to borrow, which already count collateralFactor
     */
    constructor(address _vault, address _cToken, uint256 _reserveFactor, uint8 _maxBorrowCycles) public BaseStrategy(_vault) {
        cToken = CErc20(_cToken);
        comptroller = Comptroller(cToken.comptroller());
        comp = IERC20(comptroller.getCompAddress());
        require(_reserveFactor <= EXP, '_reserveFactor too high'); //_reserveFactor should be <= 1 * EXP, otherwise borrow will fail
        reserveFactor = _reserveFactor;
        require(_maxBorrowCycles > 0, "_maxBorrowCycles should be > 0");
        maxBorrowCycles = _maxBorrowCycles;
        cTokenDecimals = IERC20Detailed(_cToken).decimals();
        underlyingDecimals = IERC20Detailed(address(want)).decimals();
        prepareBorrowing();
    }

    function setup(uint256 _reserveFactor, uint8 _maxBorrowCycles) external onlyStrategist {
        require(_reserveFactor <= EXP, '_reserveFactor too high'); //_reserveFactor should be <= 1 * EXP, otherwise borrow will fail
        reserveFactor = _reserveFactor;
        require(_maxBorrowCycles > 0, "_maxBorrowCycles should be > 0");
        maxBorrowCycles = _maxBorrowCycles;
    }

    function name() external view override returns (string memory) {
        return "StrategyCompoundErc20";
    }

    function estimatedTotalAssets() public view override returns (uint256) {
        uint256 local = want.balanceOf(address(this));
        (uint256 error, uint256 cTokenBalance, uint256 borrowBalance, uint256 exchangeRateMantissa) 
            = cToken.getAccountSnapshot(address(this));
        require(error == 0, "getAccountSnapshot failed");

        // TODO: calculate value of available COMP

        return local.add(convertCTokenToUnderlying(cTokenBalance, exchangeRateMantissa)).sub(borrowBalance);
    }

    function prepareReturn(uint256 _debtOutstanding)
        internal
        override
        returns (
            uint256 _profit,
            uint256 _loss,
            uint256 _debtPayment
        )
    {
        // TODO: Do stuff here to free up any returns back into `want`
        // NOTE: Return `_profit` which is value generated by all positions, priced in `want`
        // NOTE: Should try to free up at least `_debtOutstanding` of underlying position

        // TODO: correctly repay borrowed
        // TODO: swap COMP
        redeemFromCompound(_debtOutstanding);

        // TODO: calcultate profit/loss
    }

    function adjustPosition(uint256 _debtOutstanding) internal override {
        uint256 balance = want.balanceOf(address(this));
        if(balance <= _debtOutstanding) return; // Do nothing because we'll need to free up this funds soon.
        uint256 available = balance.sub(_debtOutstanding);
        depositAndBorrowCycled(available);
    }

    function liquidatePosition(uint256 _amountNeeded) internal override returns (uint256 _liquidatedAmount, uint256 _loss) {
        // TODO: Do stuff here to free up to `_amountNeeded` from all positions back into `want`
        // NOTE: Maintain invariant `want.balanceOf(this) >= _liquidatedAmount`
        // NOTE: Maintain invariant `_liquidatedAmount + _loss <= _amountNeeded`

        // TODO: correctly repay borrowed
        redeemFromCompound(_amountNeeded);

        uint256 totalAssets = want.balanceOf(address(this));
        if (_amountNeeded > totalAssets) {
            _liquidatedAmount = totalAssets;
            _loss = _amountNeeded.sub(totalAssets);
        } else {
            _liquidatedAmount = _amountNeeded;
        }
    }

    // NOTE: Can override `tendTrigger` and `harvestTrigger` if necessary

    function prepareMigration(address _newStrategy) internal override {
        uint256 cTokenBalance = IERC20(address(cToken)).balanceOf(address(this));
        IERC20(address(cToken)).transfer(_newStrategy, cTokenBalance);
        uint256 compBalance = comp.balanceOf(address(this));
        comp.transfer(_newStrategy, compBalance);
    }

    function protectedTokens() internal view override returns (address[] memory) {
        address[] memory protected = new address[](2);
        protected[0] = address(cToken);
        protected[0] = address(comp);
        return protected;
    }

    function depositAndBorrowCycled(uint256 underlyingAmount) internal {
        depositToCompound(underlyingAmount);

        for(uint8 c=0; c < maxBorrowCycles; c++) {
            uint256 canBorrowUsd = calculateAvailalbeToBorrow();
            if(canBorrowUsd == 0) break;
            uint256 borrowed = borrowFromCompound(canBorrowUsd);

            depositToCompound(borrowed);
        }
    }


    function depositToCompound(uint256 underlyingAmount) internal {
        //want.approve(address(cToken), underlyingAmount);
        cToken.mint(underlyingAmount);
    }

    function redeemFromCompound(uint256 underlyingAmount) internal {
        cToken.redeemUnderlying(underlyingAmount);
    }

    function calculateAvailalbeToBorrow() internal returns(uint256) {
        (uint256 error, uint256 liquidity, uint256 shortfall) = comptroller.getAccountLiquidity(address(this));
        require(error == 0, "getAccountLiquidity failed");
        // require(shortfall == 0, "account underwater");
        // require(liquidity > 0, "no liquidity");
        if(liquidity == 0 || shortfall != 0) return 0;
        uint256 usdToBorrow = liquidity.mul(reserveFactor).div(EXP);
        return  usdToBorrow;   
    }

    function borrowFromCompound(uint256 usdToBorrow) internal returns(uint256) {
        uint256 underlyingPrice = oracle.getUnderlyingPrice(address(cToken));
        uint256 borrowAmountN = usdToBorrow.div(underlyingPrice); //amount with 18 decimals
        uint256 borrowAmount = convertDecimals(borrowAmountN, 18, underlyingDecimals);

        uint256 error = cToken.borrow(borrowAmount);
        require(error == 0, "borrow failed");
        return borrowAmount;
    }

    function prepareBorrowing() internal returns(uint256 collateralFactor) {
        address[] memory cTokens = new address[](1);
        cTokens[0] = address(cToken);
        uint256[] memory errors = comptroller.enterMarkets(cTokens);
        require(errors[0] == 0, "enterMarkets failed.");
        want.approve(address(cToken), MAX_UINT256);
    }


    // TODO: convert with better precision (especially for underlying with 6 decimals)
    function convertUnderlyingToCToken(uint256 amount, uint256 exchangeRateMantissa) internal view returns(uint256) {
        return convertDecimals(amount.mul(exchangeRateMantissa).div(EXP), underlyingDecimals, cTokenDecimals);
    }
    function convertCTokenToUnderlying(uint256 amount, uint256 exchangeRateMantissa) internal view returns(uint256) {
        return convertDecimals(amount.mul(EXP).div(exchangeRateMantissa), underlyingDecimals, cTokenDecimals);
    }
    function convertDecimals(uint256 amount, uint8 decimalsFrom, uint8 decimalsTo) internal pure returns(uint256){
        if (decimalsFrom == decimalsTo) {
            return amount;
        } else if(decimalsFrom < decimalsTo) {
            uint8 dd = decimalsTo - decimalsFrom;
            return amount.mul(10**dd);
        } else { //decimalsTo < decimalsFrom
            uint8 dd = decimalsFrom - decimalsTo;
            return amount.div(10**dd);
        }
    }

}